# Интерактивные тесты по материалу вебинара «REST API биржи Event-услуг на Laravel»

**Фокус: теория и концепции** (REST, Laravel, безопасность, архитектура). Ответы и пояснения — в конце документа.

---

### 1. Зачем в API версионировать контракт через URL (например /api/v1/...)?

- a) Чтобы различать тестовый и боевой сервер  
- b) Чтобы менять формат и правила API, не ломая старых клиентов; старые продолжают ходить на v1, новые — на v2  
- c) Это требование стандарта REST  
- d) Только для удобства документации  

### 2. Почему в REST ресурсы отображаются в URL, а действие задаётся HTTP-методом (GET, POST, PUT, DELETE)?

- a) Так проще кэшировать ответы (GET — без побочных эффектов)  
- b) Один контракт для веб- и мобильных клиентов; семантика методов универсальна  
- c) Laravel так требует для resource-контроллеров  
- d) Верно a и b  

### 3. Зачем в схеме БД явно описывать связи (внешние ключи) и поведение при удалении (cascade и т.д.)?

- a) Чтобы ORM мог строить связи (hasMany, belongsTo)  
- b) Чтобы гарантировать целостность данных и явно решить, что делать с дочерними записями при удалении родителя  
- c) Только для автогенерации миграций  
- d) Чтобы ускорить запросы  

### 4. Чем токен-аутентификация (Sanctum и аналоги) принципиально отличается от сессий (cookies)?

- a) Токены нельзя украсть  
- b) HTTP остаётся без состояния: каждый запрос с токеном сам идентифицирует пользователя, без хранения сессии на сервере  
- c) Токены работают только в мобильных приложениях  
- d) Сессии не подходят для API по стандарту  

### 5. Что дают миграции по сравнению с ручным выполнением SQL в БД?

- a) Миграции быстрее выполняются  
- b) Схема БД версионируется в коде; команда получает одинаковую схему; можно откатывать изменения  
- c) Миграции обязательны для работы Eloquent  
- d) Только для создания таблиц, не для изменений  

### 6. Почему при создании записи «от имени» пользователя (например client_id) идентификатор берут из аутентификации ($request->user()->id), а не из тела запроса?

- a) В REST нельзя передавать id пользователя в теле  
- b) Иначе клиент мог бы подставить чужой id и создавать записи от имени другого пользователя; доверять можно только данным из токена  
- c) Так требует Laravel Sanctum  
- d) Чтобы сократить размер запроса  

### 7. Чем аутентификация отличается от авторизации?

- a) Это одно и то же  
- b) Аутентификация — «кто ты» (токен → пользователь); авторизация — «разрешено ли тебе это действие над этим ресурсом»  
- c) Аутентификация — для API, авторизация — для веб-форм  
- d) Авторизация проверяет только роль пользователя  

### 8. Зачем нужен слой API Resource (трансформация модели в JSON), а не отдавать модель «как есть»?

- a) Eloquent-модели нельзя сериализовать в JSON  
- b) Не отдаём лишнее (пароли, внутренние поля); единый формат ответов; удобно скрывать/добавлять поля и менять контракт в одном месте  
- c) Иначе не работает пагинация  
- d) Только для ускорения ответа  

### 9. Зачем ограничивать число запросов (rate limiting), особенно на login/register?

- a) Чтобы равномерно распределить нагрузку на БД  
- b) Защита от перебора паролей (brute force), от злоупотребления API и от простых DDoS; на чувствительных маршрутах лимит делают жёстче  
- c) Требование стандарта REST  
- d) Чтобы уменьшить трафик  

### 10. Что такое проблема N+1 запросов и как её устраняют в Laravel?

- a) Слишком много записей в одной странице; решают уменьшением per_page  
- b) В цикле по N записям для каждой подгружается связь — получается 1 + N запросов; решают eager loading (with(['relation'])) — два запроса вместо 1 + N  
- c) Слишком много индексов в БД; решают удалением индексов  
- d) Долгая валидация; решают кэшированием  

---

# Ответы и пояснения

<details>
<summary>Показать ответы</summary>

- **1 — b.** Версионирование в URL даёт возможность менять контракт (поля, форматы, правила), не ломая старых клиентов: v1 остаётся стабильным, v2 — новый контракт.
- **2 — d.** И кэширование (GET без побочных эффектов), и единый контракт для разных клиентов — оба аргумента верны.
- **3 — b.** Внешние ключи и каскады гарантируют целостность и явно задают поведение при удалении; ORM опирается на эту схему.
- **4 — b.** Токен передаётся с каждым запросом; сервер не хранит сессию — HTTP остаётся stateless.
- **5 — b.** Миграции — это версионирование схемы в коде; команда применяет одни и те же шаги; возможен откат.
- **6 — b.** Идентификатор пользователя из токена нельзя подделать в теле запроса — это вопрос безопасности.
- **7 — b.** Аутентификация определяет пользователя; авторизация проверяет право на действие над конкретным ресурсом.
- **8 — b.** API Resource — слой трансформации: скрытие полей, единый формат, условная логика.
- **9 — b.** Rate limiting защищает от brute force, злоупотребления и простых DDoS; на login/register лимит строже.
- **10 — b.** N+1 — лишние запросы при подгрузке связей в цикле; with() даёт eager loading.
</details>
